#!/usr/bin/env bash

version="1.0.0"

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS

print_help ()
{
	echo "Delete all resource associated with a label"
	printf 'Usage: %s [-v|--version] [-h|--help] <label>\n' "$0"
	printf "\t%s\n" "<label>: The label of resource, eg. app=appName"
	printf "\t%s\n" "-v,--version: Prints version"
	printf "\t%s\n" "-h,--help: Prints help"
}

# THE PARSING ITSELF
while test $# -gt 0
do
	_key="$1"
	case "$_key" in
	    -v*|--version)
			echo ${version}
			exit 0
			;;
		-h*|--help)
			print_help
			exit 0
			;;
		*)
			_positionals+=("$1")
			;;
	esac
	shift
done

_positional_names=('_arg_label' )
_required_args_string="'label'"
test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
	eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

delete_app()
{
    delete_app_error=`oc delete all -l ${_positionals} 2>&1`
    if [ $? -eq 0 ]; then
      echo {\"success\": \"true\"}
    else
      echo {\"success\": \"false\", \"error\": \"${delete_app_error}\"}
    fi
}

delete_app